import React from 'react';
import { act, renderHook } from 'react-hooks-testing-library';

import { createCache } from '../../../../src/cache/cache';
import { Action, QueryResponse, SuspenseCacheItem } from '../../../../src/client/client.types';
import { ClientContextProvider } from '../../../../src/context/clientContext/clientContextProvider';
import { useBulkMutation } from '../../../../src/hooks/useBulkMutation/useBulkMutation';

describe('useBulkMutation test', () => {
  const actionCreator: any = jest.fn((endpoint: string): Action => ({
    endpoint,
    method: 'GET',
  }));

  const fetchFunction: (action: Action) => Promise<QueryResponse> = async (action) => ({
    error: false,
    payload: {
      foo: action.endpoint,
    },
    status: 200,
  });

  const client = {
    query: fetchFunction,
    suspenseCache: createCache<SuspenseCacheItem>(() => true, () => true),
  };

  const wrapper = ({ children }: any) => <ClientContextProvider client={client}>{children}</ClientContextProvider>;

  it('fetches resource and returns proper data on success', async () => {
    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['foo']);
    });

    expect(state.loading).toEqual(true);

    act(() => {
      jest.runAllTimers();
    });

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(1);
    expect(state.responses[0].payload).toEqual({
      foo: 'foo',
    });

    act(() => {
      state.reset();
    });

    expect(state.responses).toHaveLength(0);
  });

  it('fetches multiple resources and returns proper data on success', async () => {
    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['foo', 'bar']);
    });

    expect(state.loading).toEqual(true);
    expect(actionCreator).toHaveBeenCalledWith('foo');
    expect(actionCreator).toHaveBeenCalledWith('bar');

    act(() => {
      jest.runAllTimers();
    });

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(2);
    expect(state.responses[0].payload).toEqual({
      foo: 'foo',
    });
    expect(state.responses[1].payload).toEqual({
      foo: 'bar',
    });

    act(() => {
      state.reset();
    });

    expect(state.responses).toHaveLength(0);
  });

  it('allows to define a promise wrapper to implement things like throttling', async () => {
    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    const resolvers = {
      foo: jest.fn(),
      bar: jest.fn()
    };

    act(() => {
      state.mutate(['foo', 'bar'], (promiseFn: any, action: any) => {
        return new Promise((resolver) => {
          if (action.endpoint === 'foo') {
            resolvers.foo.mockImplementation(() => resolver(promiseFn()));
          } else if (action.endpoint === 'bar') {
            resolvers.bar.mockImplementation(() => resolver(promiseFn()));
          }
        });
      });
    });

    expect(state.loading).toEqual(true);
    expect(actionCreator).toHaveBeenCalledWith('foo');
    expect(actionCreator).toHaveBeenCalledWith('bar');

    act(() => {
      jest.runAllTimers();
    });

    expect(state.loading).toEqual(true);

    act(() => {
      resolvers.bar();
      jest.runAllTimers();
    });

    expect(state.loading).toEqual(true);

    act(() => {
      resolvers.foo();
      jest.runAllTimers();
    });

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(2);
    expect(state.responses[0].payload).toEqual({
      foo: 'foo',
    });
    expect(state.responses[1].payload).toEqual({
      foo: 'bar',
    });

    act(() => {
      state.reset();
    });

    expect(state.responses).toHaveLength(0);
  });

  it('skips changing state after unmount', async () => {
    jest.useFakeTimers();

    let state: any = {};

    const { unmount } = renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    await unmount();

    act(() => {
      state.mutate(['endpoint']);
      jest.runAllTimers();
    });

    expect(actionCreator).not.toHaveBeenCalledWith('endpoint');

    expect(state.loading).toEqual(false);
  });

  it('skips changing state after unmount during fetch', async () => {
    jest.useFakeTimers();

    let state: any = {};

    const { unmount } = renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['endpoint']);
      unmount();
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('endpoint');

    expect(state.loading).toEqual(false);
  });

  it('aborts requests during race conditions', async () => {
    const abort = jest.fn();
    const abortController = jest.fn(() => ({ abort }));
    Object.defineProperty(window, 'AbortController', { value: abortController, writable: true });

    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['endpoint']);
      state.mutate(['endpoint']);
      state.mutate(['endpoint']);
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('endpoint');

    expect(abortController).toHaveBeenCalledTimes(3); // count of creater abort controllers
    expect(abort).toHaveBeenCalledTimes(2); // count of aborted requests
  });

  it('resets loading and abort controller after abort', async () => {
    const abort = jest.fn();
    const abortController = jest.fn(() => ({ abort }));
    Object.defineProperty(window, 'AbortController', { value: abortController, writable: true });

    const localFetchFunction: () => Promise<QueryResponse> = async () => ({
      error: true,
      errorObject: {
        name: 'AbortError'
      }
    });

    const localClient = {
      query: localFetchFunction,
      suspenseCache: createCache<SuspenseCacheItem>(() => true, () => true),
    };

    const localWrapper = ({ children }: any) => <ClientContextProvider client={localClient}>{children}</ClientContextProvider>;

    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper: localWrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['endpoint']);
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('endpoint');
    expect(state.loading).toEqual(false);
  });

  it('support manual abort', async () => {
    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['endpoint']);
      state.abort();
      state.mutate(['endpoint']);
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('endpoint');
    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(1);
  });

  it('works without AbortController', async () => {
    delete(window.AbortController);

    const localFetchFunction: () => Promise<QueryResponse> = async () => ({
      error: true,
      errorObject: {
        name: 'AbortError'
      }
    });

    const localClient = {
      query: localFetchFunction,
      suspenseCache: createCache<SuspenseCacheItem>(() => true, () => true),
    };

    const localWrapper = ({ children }: any) => <ClientContextProvider client={localClient}>{children}</ClientContextProvider>;

    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper: localWrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['endpoint']);
      state.mutate(['endpoint']);
      state.mutate(['endpoint']);
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('endpoint');
    expect(state.loading).toEqual(false);
  });

  it('may return errors and success responses', async () => {

    const localFetchFunction: (action: Action) => Promise<QueryResponse> = async (action) => {
      if (action.endpoint === 'error') {
        return {
          error: true,
          errorObject: {
            name: 'Some error'
          }
        }
      }

      return {
        error: false,
        payload: {
          foo: action.endpoint,
        },
        status: 200,
      };
    };

    const localClient = {
      query: localFetchFunction,
      suspenseCache: createCache<SuspenseCacheItem>(() => true, () => true),
    };

    const localWrapper = ({ children }: any) => <ClientContextProvider client={localClient}>{children}</ClientContextProvider>;

    jest.useFakeTimers();

    let state: any = {};

    renderHook(
      () => {
        state = useBulkMutation(actionCreator);
      },
      {
        wrapper: localWrapper,
      },
    );

    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(0);

    act(() => {
      state.mutate(['foo', 'error', 'bar']);
      jest.runAllTimers();
    });

    expect(actionCreator).toHaveBeenCalledWith('foo');
    expect(actionCreator).toHaveBeenCalledWith('error');
    expect(actionCreator).toHaveBeenCalledWith('bar');
    expect(state.loading).toEqual(false);
    expect(state.responses).toHaveLength(3);
    expect(state.responses[0].error).toEqual(false);
    expect(state.responses[1].error).toEqual(true);
    expect(state.responses[2].error).toEqual(false);
  });
});
